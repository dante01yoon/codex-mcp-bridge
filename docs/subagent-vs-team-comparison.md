# 서브에이전트(Task) vs 클로드 팀(TeamCreate) 비교 분석

> 작성일: 2026-02-15
> 대상: Claude Code의 두 가지 멀티에이전트 패턴

---

## 목차

- [1. 정의](#1-정의)
- [2. 구조적 차이: 정보 흐름](#2-구조적-차이-정보-흐름)
- [3. 근본적 결과의 차이](#3-근본적-결과의-차이)
- [4. 컨텍스트 사용량 정량 분석](#4-컨텍스트-사용량-정량-분석)
- [5. 비용 비교](#5-비용-비교)
- [6. 판단 기준: 언제 무엇을 쓰는가](#6-판단-기준-언제-무엇을-쓰는가)
- [7. OpenCode와의 비교](#7-opencode와의-비교)
- [출처](#출처)

---

## 1. 정의

### 서브에이전트 (Task 도구)

일을 시키고 결과만 받는 **일회성 위임**.

```
메인 Claude
  │
  ├─ Task("파일 A 분석해줘") ──→ 서브에이전트 A
  │       (대기...)                  분석 중...
  │   ←── "결과: 취약점 3개"         종료 (소멸)
  │
  └─ 결과를 바탕으로 다음 작업
```

- Task 도구로 생성되는 독립적인 에이전트 프로세스
- 새로운 빈 컨텍스트에서 시작 (이전 대화를 받지 않음)
- 작업 완료 후 결과를 반환하고 소멸
- 서브에이전트끼리 서로 모르고, 대화 불가

### 팀 (TeamCreate)

여러 에이전트가 서로 소통하며 **지속적으로 협업**.

```
┌─ 팀 ────────────────────────────────────────────────┐
│                                                      │
│  리더 (메인) ←──── SendMessage ────→ frontend-dev    │
│      │                                    │          │
│      │          SendMessage              │          │
│      │              ↕                    ↕          │
│      └──────→ backend-dev ←──────→ tester           │
│                                                      │
│  공유 TaskList:                                      │
│  ├─ [완료] API 설계                                  │
│  ├─ [진행중] 프론트엔드 구현 (owner: frontend-dev)    │
│  ├─ [대기] 백엔드 구현 (owner: backend-dev)           │
│  └─ [대기] 테스트 작성 (blockedBy: 프론트+백엔드)     │
└──────────────────────────────────────────────────────┘
```

- TeamCreate로 생성, 명시적 shutdown까지 지속
- 에이전트끼리 SendMessage로 직접 소통 가능
- 공유 TaskList로 작업 조율, 의존성 관리
- 팀원이 스스로 다음 작업을 찾아서 수행

### 기능 비교표

| | 서브에이전트 (Task) | 팀 (TeamCreate) |
|---|---|---|
| **수명** | 작업 완료 후 소멸 | 명시적 shutdown까지 지속 |
| **소통** | 메인↔서브만 가능 | 모든 에이전트 간 가능 |
| **소통 방식** | 결과 반환 (자동) | SendMessage (명시적 메시지) |
| **작업 관리** | 없음 (단일 작업) | 공유 TaskList + 의존성 관리 |
| **자율성** | 주어진 작업만 수행 | 스스로 다음 작업 탐색 가능 |
| **컨텍스트** | 빈 컨텍스트에서 시작 | 각자 독립 컨텍스트, 메시지로 공유 |
| **복잡도** | 낮음 | 높음 |

---

## 2. 구조적 차이: 정보 흐름

이 차이가 이후 모든 결과의 원인이다.

### 서브에이전트: 별(star) 구조

```
        서브A
         ↑↓
서브C ←→ 메인 ←→ 서브B
         ↑↓
        서브D

모든 정보가 반드시 메인을 통과해야 한다.
서브A의 발견을 서브B에게 전달하려면 메인이 중계해야 한다.
```

### 팀: 그물(mesh) 구조

```
  A ←──→ B
  ↕  ╲╱  ↕
  ↕  ╱╲  ↕
  C ←──→ D

정보가 필요한 곳으로 직접 흐른다.
A가 발견한 것을 B에게 직접 전달할 수 있다.
리더가 중계할 필요가 없다.
```

---

## 3. 근본적 결과의 차이

정보 흐름 구조가 다르기 때문에, 세 가지 근본적인 결과 차이가 발생한다.

### 결과 1: 예상치 못한 발견에 대한 대응

#### 서브에이전트: 메인이 병목이 된다

```
메인: "runner.py 분석해줘"
서브A: (분석 중 발견) "runner.py가 config.py에 심각하게 의존하고 있다"
서브A → 메인: "의존성 발견, config.py도 봐야 합니다"
서브A: 종료 (소멸)

메인: "그러면 config.py도 분석해야겠군"
메인 → 서브B: "config.py 분석해줘"
서브B: (서브A가 뭘 발견했는지 모름. 메인이 prompt에 넣어줘야 함)
```

서브A가 발견한 것을 서브B에게 전달하려면 반드시 메인을 거쳐야 한다.
메인이 정보를 선별하고 다시 전달하는 병목이 생긴다.

#### 팀: 팀원이 직접 해결한다

```
backend-dev: (구현 중 발견) "인증 토큰 형식을 바꿔야 한다"
backend-dev → frontend-dev: "토큰이 JWT에서 opaque로 바뀐다"
frontend-dev: (즉시 반영) "알겠다, 디코딩 로직 제거한다"

리더는 이 교환을 간접적으로 알게 됨 (idle 알림에 요약 포함)
리더가 개입할 필요 없이 문제가 해결됨
```

팀원이 직접 소통하므로 리더가 병목이 되지 않는다.

### 결과 2: 작업 규모가 커질수록 차이가 벌어진다

#### 서브에이전트: 조율 비용이 메인을 압도한다

```
작업 규모가 커지면:

메인의 부담:
├─ 서브A 결과 읽기 + 이해
├─ 서브B에게 전달할 맥락 선별
├─ 서브B 결과 읽기 + 이해
├─ 서브C에게 전달할 맥락 선별 (A+B 결과 포함)
├─ ...
└─ 메인의 컨텍스트가 결국 다시 가득 참

서브에이전트를 써서 컨텍스트를 보호하려 했지만,
조율 비용이 커지면서 메인 컨텍스트가 다시 차는 역설.
```

#### 팀: 조율이 분산된다

```
작업 규모가 커지면:

리더의 부담:
├─ 작업 분배 (TaskCreate)
├─ 완료 알림 수신 (자동)
└─ 최종 검토

세부 조율은 팀원끼리 직접 해결.
리더 컨텍스트에는 세부 내용이 들어오지 않는다.
```

### 결과 3: "모르는 것을 모르는" 상황 — 가장 중요한 차이

#### 서브에이전트: 메인이 모든 것을 미리 알아야 한다

```
메인이 해야 하는 일:
1. 작업을 정확히 분해할 수 있어야 한다
2. 각 서브에이전트에게 충분한 맥락을 제공해야 한다
3. 결과를 통합할 수 있어야 한다

→ 메인이 문제를 충분히 이해하고 있을 때만 잘 동작한다.
→ 문제를 잘 모르는 상태에서는 올바른 지시를 내릴 수 없다.
```

#### 팀: 탐색하면서 알아갈 수 있다

```
리더: "인증 시스템을 만들자. 일단 시작해봐."

backend-dev: (작업하면서 발견) "OAuth가 필요하다"
backend-dev → frontend-dev: "OAuth 콜백 처리 필요"
frontend-dev: (작업하면서 발견) "모바일은 PKCE가 필요하다"
frontend-dev → backend-dev: "PKCE 지원 추가해줘"
tester: TaskList 확인 → 완료된 것부터 테스트 시작

→ 사전에 모든 것을 알지 못해도, 팀이 탐색하면서 적응한다.
```

### 요약: 근본적 차이의 원인과 결과

| | 서브에이전트 | 팀 |
|---|---|---|
| **정보 흐름** | 별(star) — 메인 중심 | 그물(mesh) — 분산 |
| **예상 밖 발견** | 메인이 중계해야 함 (병목) | 팀원이 직접 해결 |
| **규모 확장** | 조율 비용이 메인을 압도 | 조율이 분산됨 |
| **탐색적 문제** | 미리 분해할 수 있어야 함 | 진행하면서 적응 가능 |

근본 원인: **조율이 중앙집중(서브에이전트)인가, 분산(팀)인가.**
근본 결과: **알려진 문제에 강한가, 미지의 문제에 강한가.**

---

## 4. 컨텍스트 사용량 정량 분석

### 패턴별 토큰 소비 (단일 에이전트 대비)

| 패턴 | 토큰 배수 | 근거 |
|---|:-:|---|
| **단일 에이전트** | 1x (기준) | 하나의 컨텍스트에서 모든 작업 |
| **서브에이전트 (Task)** | **~4x** | Anthropic: "에이전트는 채팅 대비 4x 토큰 사용" |
| **팀 (3명)** | **3-4x** | 팀원별 독립 컨텍스트 + 조율 오버헤드 |
| **팀 (5명)** | **~5x** | 팀 규모에 비례하여 증가 |
| **팀 (플랜 모드)** | **~7x** | 플랜 모드가 추가 오버헤드 발생 |

### 컨텍스트 보호 효과

```
서브에이전트 없이 탐색 (메인 컨텍스트):
  Grep 결과 1:  +200줄  (~1,400 토큰)
  Grep 결과 2:  +150줄  (~1,050 토큰)
  파일 읽기 1:  +400줄  (~2,800 토큰)
  파일 읽기 2:  +300줄  (~2,100 토큰)
  ─────────────────────────────
  메인 컨텍스트 증가: ~7,350 토큰

서브에이전트로 위임 (격리):
  서브에이전트 내부: 7,350 토큰 소비 후 폐기
  메인에 반환: 요약 ~200 토큰
  ─────────────────────────────
  메인 컨텍스트 증가: ~200 토큰

  → 메인 컨텍스트 절약: ~97%
```

### 핵심 트레이드오프

```
                  총 토큰 소비    메인 컨텍스트 보호    세션 수명
단일 에이전트       낮음            없음               짧음
서브에이전트        중간 (~4x)     높음 (97% 절약)     길어짐
팀               높음 (3-7x)     높음               길어짐
```

> **서브에이전트는 총 토큰을 4배 더 쓰지만, 메인 컨텍스트를 97% 보호한다.**
> **팀은 총 토큰을 3-7배 더 쓰지만, 조율 비용이 분산되어 리더 컨텍스트를 보호한다.**

### 연구 데이터

| 연구 | 발견 |
|---|---|
| Anthropic 멀티에이전트 연구 | 멀티에이전트가 4-220x 더 많은 input 토큰 사용 |
| 컨텍스트 격리 (stateless 설계) | 전체 처리 토큰 67% 감소 |
| AgentDropout (ACL 2025) | 프롬프트 토큰 21.6% 감소, 완성 토큰 18.4% 감소 가능 |
| Opus 4.5 장기 작업 | 단일 모델 최적화로 최대 65% 적은 토큰 |
| 스킬 기반 단일에이전트 연구 | 멀티에이전트 대비 토큰 54% 감소, 지연 50% 감소 |

---

## 5. 비용 비교

### Claude API 가격표 (2026)

| 모델 | Input ($/M 토큰) | Output ($/M 토큰) |
|---|---|---|
| Haiku 4.5 | $1 | $5 |
| Sonnet 4.5 | $3 | $15 |
| Opus 4.5/4.6 | $5 | $25 |

### 패턴별 비용 예시 (30분 작업 기준)

```
단일 에이전트:      ~$1.00  (기준)
서브에이전트 3회:    ~$2.00  (탐색 위임, 메인은 가벼움)
3인 팀:            ~$3.00-4.00  (각 팀원 독립 컨텍스트)
5인 팀 + 플랜:     ~$5.00-7.00  (조율 오버헤드 포함)
```

### 비용 최적화 전략

| 전략 | 절감률 |
|---|---|
| 프롬프트 캐싱 (캐시 읽기) | 최대 90% |
| Batch API | 50% |
| 서브에이전트에 Haiku 사용 | Opus 대비 80% 절감 |
| 토큰 효율적 도구 사용 (베타) | 출력 토큰 최대 70% 감소 |

### 서브에이전트 모델 분리 전략

```
비용 효율 최적 구성:

메인 에이전트:     Opus ($5/$25)    — 복잡한 추론, 최종 판단
서브 (탐색):      Haiku ($1/$5)    — 파일 검색, 패턴 매칭
서브 (코드 생성):  Sonnet ($3/$15)  — 코드 작성, 분석
Codex MCP:        OpenAI 사용량     — Claude 토큰 절약

모두 Opus vs 혼합 구성 (탐색 3회 + 코드 생성 2회):
  모두 Opus: $0.50
  혼합 구성: $0.18  → 64% 절약
```

---

## 6. 판단 기준: 언제 무엇을 쓰는가

### 의사결정 트리

```
문제를 잘 알고 있는가?
  │
  ├─ YES: 명확히 분해 가능한 작업
  │   │
  │   ├─ 작업 간 소통 필요?
  │   │   ├─ NO → 서브에이전트 (독립적 위임)
  │   │   └─ YES → 팀
  │   │
  │   └─ 병렬 실행 가능?
  │       ├─ YES → 서브에이전트 병렬
  │       └─ NO → 서브에이전트 순차
  │
  └─ NO: 진행하면서 알아가야 하는 작업
      │
      ├─ 규모가 작다 → 서브에이전트 순차 (탐색 → 결과 기반 다음 단계)
      └─ 규모가 크다 → 팀 (탐색적 협업)
```

### 구체적 예시

#### 서브에이전트가 적합한 경우

```
"이 3개 파일을 각각 분석해줘"
→ 독립적 작업 3개. 서로 소통 불필요. 서브에이전트 병렬.

"runner.py 코드를 Codex로 개선안 만들어줘"
→ 단일 위임. 결과만 받으면 됨. 서브에이전트 순차.

"테스트 코드 자동 생성해줘"
→ 기존 코드 기반 반복 작업. 서브에이전트에 위임 후 검토.
```

#### 팀이 적합한 경우

```
"인증 시스템을 새로 만들어줘"
→ 프론트/백엔드/테스트 간 조율 필요. 진행하면서 요구사항 발견.

"이 프로젝트를 전체 리팩토링해줘"
→ 파일 간 의존성, 변경 영향 범위 미지. 탐색적 접근 필요.

"마이크로서비스 아키텍처로 전환해줘"
→ 여러 서비스 간 인터페이스 협의. 장기 협업.
```

### 관계 정리

```
서브에이전트는 팀의 "부분집합"이 아니라, 별개의 도구이다.

서브에이전트:
  "이거 해오고 결과 알려줘" → 상하 관계, 단발성

팀:
  "우리 같이 이 프로젝트 하자" → 동료 관계, 지속성
  팀 내부에서도 Task를 써서 서브에이전트를 추가 생성할 수 있음
```

---

## 7. OpenCode와의 비교

### OpenCode의 서브에이전트

OpenCode(oh-my-opencode)도 유사한 두 패턴을 갖고 있다:

| | Claude Code | OpenCode |
|---|---|---|
| **서브에이전트 도구** | Task | call_omo_agent, sisyphus_task |
| **팀/지속적 협업** | TeamCreate + SendMessage | background_task + BackgroundManager |
| **서브에이전트 중첩** | general-purpose만 가능 | 불가 (재귀 방지 차단) |
| **에이전트 수** | 5개 타입 | 10개 내장 + Sisyphus-Junior (동적) |
| **모델 선택** | Claude 전용 | 75+ 프로바이더 (에이전트별 다른 모델) |

### 동일한 원리

두 시스템 모두 동일한 근본 원리가 적용된다:

- 서브에이전트: 별 구조, 메인 중심 조율, 일회성
- 팀/백그라운드: 분산 조율, 지속적, 자율적

차이는 구현 방식이지 개념이 아니다.

---

## 출처

### Anthropic 공식
- [Anthropic 멀티에이전트 연구 시스템](https://www.anthropic.com/engineering/multi-agent-research-system)
- [Claude Code Agent Teams 문서](https://code.claude.com/docs/en/agent-teams)
- [Claude API 가격](https://platform.claude.com/docs/en/about-claude/pricing)
- [Claude Code 비용 관리](https://code.claude.com/docs/en/costs)
- [토큰 절약 업데이트](https://www.anthropic.com/news/token-saving-updates)
- [컨텍스트 윈도우](https://platform.claude.com/docs/en/build-with-claude/context-windows)

### 학술 연구
- [ACON: 장기 LLM 에이전트 컨텍스트 압축 최적화](https://arxiv.org/html/2510.00615v1)
- [AgentDropout: 동적 에이전트 제거 (ACL 2025)](https://aclanthology.org/2025.acl-long.1170/)
- [스킬 기반 단일에이전트가 멀티에이전트를 대체할 때](https://www.arxiv.org/pdf/2601.04748)
- [효율적 런타임 멀티에이전트 시스템](https://arxiv.org/html/2510.26585v1)

### 분석
- [Claude Code 토큰 한도 가이드](https://www.faros.ai/blog/claude-code-token-limits)
- [Claude Code Agent Teams 튜토리얼](https://claudefa.st/blog/guide/agents/agent-teams)
- [서브에이전트 vs 팀 아키텍처](https://www.ibuildwith.ai/blog/task-tool-vs-subagents-how-agents-work-in-claude-code/)
- [Claude Code 컨텍스트 보호](https://hyperdev.matsuoka.com/p/how-claude-code-got-better-by-protecting)

### OpenCode / oh-my-opencode
- [OpenCode Agents 문서](https://opencode.ai/docs/agents/)
- [oh-my-opencode Agent Orchestration Overview](https://deepwiki.com/code-yeongyu/oh-my-opencode/4.1-agent-orchestration-overview)
- [OpenCode 토큰 사용량 최적화](https://www.truefoundry.com/blog/opencode-token-usage-how-it-works-and-how-to-optimize-it)
